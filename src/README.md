# Simple Docker

## Part 1. Готовый докер

##### При помощи `docker pull` скачали официальный образ с **nginx**.


![](Screenshots/1.1.png)


##### Проверили наличие докер образа через `docker images`, запустили при помощи `docker run -d [image_id|repository]` и проверили, что запустилось через `docker ps`.


![](Screenshots/1.2.png)


##### Посмотрели информацию о контейнере через `docker inspect [container_id|container_name]` переместив вывод команды в docker_inspect.


![](Screenshots/1.3.png)


##### По выводу команды определили:
`Размер контейнера`


![](Screenshots/1.5.png)


`Список замапленных портов и ip контейнера`


![](Screenshots/1.6.png)


##### Остановили докер образ через `docker stop [container_id|container_name]`, проверили, что образ остановился через `docker ps`.


![](Screenshots/1.7.png)


##### Запустили докер с замапленными портами 80 и 443 на локальную машину через команду *run* и проверили, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.


![](Screenshots/1.8.png)


![](Screenshots/1.10.png)


##### Перезапустили докер контейнер через `docker restart [container_id|container_name]`и проверили с помощью `docker ps`, что контейнер запустился.


![](Screenshots/1.9.png)


## Part 2. Операции с контейнером

Докер образ и контейнер готовы. Теперь можно покопаться в конфигурации **nginx** и отобразить статус страницы.

**== Задание ==**

##### Прочитали конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*.


![](Screenshots/2.1.png)


##### Создали на локальной машине файл *nginx.conf*. Настроили в нем по пути */status* отдачу страницы статуса сервера **nginx**.


![](Screenshots/2.2.png)


##### Скопировали созданный файл *nginx.conf* внутрь докер образа через команду `docker cp`. Перезапустили **nginx** внутри докер образа через команду *exec*. Проверили, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.


![](Screenshots/2.3.png)


##### Экспортировали контейнер в файл *container.tar* через команду *export*. Остановили контейнер. Удалили образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры.


![](Screenshots/2.4.png)


##### Удалили остановленный контейнер. Импортировали контейнер обратно через команду *import*. Запустили импортированный контейнер. Проверили, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.


![](Screenshots/2.5.png)


## Part 3. Мини веб-сервер

##### Написала мини сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello World!`.


![](Screenshots/3.1.png)


##### Написала nginx.conf который будет проксировать запросы с 81 порта на 127.0.0.1:8000.


![](Screenshots/3.2.png)


##### Запустила докер с замапленным портом 81.


![](Screenshots/3.3.png)


##### Скопировала server.c и nginx.conf в докер.


![](Screenshots/3.4.png)


##### Получила доступ к запущенному контейнеру с помощью команды `docker exec -it container_id bash` и проверила наличие файла nginx.conf `cat /etc/nginx/nginx.conf`.


![](Screenshots/3.5.png)


##### Проверила наличие файла server.c `cat /home/server.c`.


![](Screenshots/3.6.png)


##### Для компиляции server.c установили gcc, spawn-fcgi и libfcgi-dev
`apt-get update / apt-get install gcc spawn-fcgi libfcgi-dev`.


![](Screenshots/3.7.png)


##### Скомпилировала server.c `gcc /home/server.c -lfcgi -o server` и запустила написанный мини сервер через *spawn-fcgi* на порту 8080 `spawn-fcgi -p 8080 ./server`. Перезапустила nginx `nginx -s reload`. Проверила, что в браузере по *localhost:81* отдается написанная страничка `curl localhost:81`.


![](Screenshots/3.8.png)


## Part 4. Свой докер

#### Написала свой докер файл `nano Docker`, который копирует в контейнер небходимые файлы, запускает команды установки, присвоения прав доступа и скрипт.


![](Screenshots/4.1.png)


#### Написала скрипт для Dockerfile `nano commands.sh`, который содержит команды для компиляции, запускает написанный мини сервер на 8080 порту и запускает **nginx**.


![](Screenshots/4.2.png)


##### Собрала написанный докер образ через `docker build` при этом указав имя и тег.


![](Screenshots/4.3.png)


##### Проверила через `docker images`, что все собралось корректно.


![](Screenshots/4.4.png)


##### Запустила собранный докер образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**.


![](Screenshots/4.5.png)


##### Проверила, что по *localhost:80* доступна страничка написанного мини сервера.


![](Screenshots/4.6.png)


##### Дописала в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.

![](Screenshots/4.7.png)


##### Проверила, что по *localhost:80/status* отдается страничка со статусом **nginx**.


![](Screenshots/4.8.png)


## Part 5. **Dockle**

##### Установила утилиту Dockle `https://habr.com/ru/company/timeweb/blog/561378/`.


![](Screenshots/5.1.png)


##### Просканировала образ из предыдущего задания через `dockle [image_id|repository]`.


![](Screenshots/5.2.png)


##### Исправила образ так, чтобы при проверке через **dockle** не было ошибок и предупреждений `dockle -ak NGINX_GPGKEY docker:test`.


![](Screenshots/5.3.png)


## Part 6. Базовый **Docker Compose**

##### Написала файл *docker-compose.yml* `nano docker-compose.yml` и замапила 8080 порт второго контейнера на 80 порт локальной машины.


![](Screenshots/6.1.png)


##### Подняла докер контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.


![](Screenshots/6.2.png)


##### Собрала проект с помощью команды `docker-compose build`.


![](Screenshots/6.3.png)


##### Проверила, что контейнеры собраны.


![](Screenshots/6.4.png)


##### Запустила проект с помощью команды `docker-compose up`. Проверила, что контейнеры запущены. Проверила, что по *localhost:80* отдается написанная страничка.


![](Screenshots/6.5.png)